package scalaomg.client.room

import akka.actor.{ActorRef, ActorSystem}
import akka.pattern.ask
import scalaomg.client.utils.MessageDictionary._
import scalaomg.common.communication.CommunicationProtocol.SessionId.SessionId
import scalaomg.common.communication.CommunicationProtocol.SocketSerializable
import scalaomg.common.room.Room.RoomId
import scalaomg.common.room.RoomProperty

import scala.concurrent.Future
import scala.util.{Failure, Success}

/**
 * Represent and instance of a joined room.
 * This type of room is generated by joining or reconnecting to [[scalaomg.client.room.JoinableRoom]]
 */
trait JoinedRoom extends ClientRoom {
  /**
   * @return the session id of this client associated to the room.
   */
  def sessionId: SessionId

  /**
   * Leave this room server side
   *
   * @return success if this room can be left, fail otherwise
   */
  def leave(): Future[Any]

  /**
   * Send a message to the server room
   *
   * @param msg the message to send
   */
  def send(msg: SocketSerializable): Unit

  /**
   * Callback that handle  message received from the server room
   *
   * @param callback callback to handle the message
   */
  def onMessageReceived(callback: Any => Unit): Unit

  /**
   * This event is triggered when the server updates its state.
   *
   * @param callback callback to handle the change of state
   */
  def onStateChanged(callback: Any => Unit): Unit

  /**
   * This event is triggered when the room is closed
   *
   * @param callback callback to handle the event
   */
  def onClose(callback: => Unit): Unit

  /**
   * This event is triggered when an error occurs
   *
   * @param callback callback to handle the event
   */
  def onError(callback: Throwable => Unit): Unit


}

private[client] object JoinedRoom {
  def apply(innerActor: ActorRef, sessionId: SessionId, roomId: RoomId, properties: Set[RoomProperty])
           (implicit system: ActorSystem): JoinedRoom =
    new JoinedRoomImpl(innerActor, sessionId, roomId, properties)
}

private class JoinedRoomImpl(private val innerActor: ActorRef,
                             override val sessionId: SessionId,
                             override val roomId: RoomId,
                             override val properties: Set[RoomProperty])
                            (override implicit val system: ActorSystem)
  extends ClientRoomImpl(roomId, properties) with JoinedRoom {


  override def leave(): Future[Any] =
    this.innerActor ? SendLeave flatMap {
      case Success(_) => Future.successful()
      case Failure(ex) => Future.failed(ex)
    }

  override def send(msg: SocketSerializable): Unit = this.innerActor ! SendStrictMessage(msg)

  override def onMessageReceived(callback: Any => Unit): Unit = this.innerActor ! OnMsgCallback(callback)

  override def onStateChanged(callback: Any => Unit): Unit = this.innerActor ! OnStateChangedCallback(callback)

  override def onClose(callback: => Unit): Unit = this.innerActor ! OnCloseCallback(() => callback)

  override def onError(callback: Throwable => Unit): Unit = this.innerActor ! OnErrorCallback(callback)
}